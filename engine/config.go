package engine

import (
	"github.com/funkygao/funpipe/rule"
	"sync"
)

type PipelineConfig struct {
	*rule.RuleEngine

	InputRunners  map[string]InputRunner
	inputWrappers map[string]*PluginWrapper

	FilterRunners  map[string]FilterRunner
	filterWrappers map[string]*PluginWrapper

	OutputRunners  map[string]OutputRunner
	outputWrappers map[string]*PluginWrapper

	router *messageRouter

	inputRecycleChan  chan *PipelinePack
	injectRecycleChan chan *PipelinePack
	reportRecycleChan chan *PipelinePack

	// Stores log messages generated by plugin config errors.
	logMsgs []string

	hostname string
	pid      int32
}

func NewPipelineConfig(ruleEngine *rule.RuleEngine) (config *PipelineConfig) {
	config = new(PipelineConfig)
	config.RuleEngine = ruleEngine

	config.InputRunners = make(map[string]InputRunner)
	config.inputWrappers = make(map[string]*PluginWrapper)
	config.FilterRunners = make(map[string]FilterRunner)
	config.filterWrappers = make(map[string]*PluginWrapper)
	config.OutputRunners = make(map[string]OutputRunner)
	config.outputWrappers = make(map[string]*PluginWrapper)

	config.router = NewMessageRouter()

	config.inputRecycleChan = make(chan *PipelinePack, 1024)
	config.injectRecycleChan = make(chan *PipelinePack, 1024)
	config.reportRecycleChan = make(chan *PipelinePack, 1)

	config.logMsgs = make([]string, 0, 4)
	config.hostname, _ = os.Hostname()
	config.pid = int32(os.Getpid())

	return config
}

// Callers should pass in the msgLoopCount value from any relevant Message
// objects they are holding. Returns a PipelinePack for injection into Heka
// pipeline, or nil if the msgLoopCount is above the configured maximum.
func (this *PipelineConfig) PipelinePack(msgLoopCount uint) *PipelinePack {
	if msgLoopCount++; msgLoopCount > Globals().MaxMsgLoops {
		return nil
	}
	pack := <-this.injectRecycleChan
	pack.Message.SetTimestamp(time.Now().UnixNano())
	pack.Message.SetUuid(uuid.NewRandom())
	pack.Message.SetHostname(this.hostname)
	pack.Message.SetPid(this.pid)
	pack.RefCount = 1
	pack.MsgLoopCount = msgLoopCount
	return pack
}

func (this *PipelineConfig) OutputRunner(name string) (or OutputRunner, ok bool) {
	or, ok = this.OutputRunners[name]
	return
}

func (this *PipelineConfig) FilterRunner(name string) (fr FilterRunner, ok bool) {
	fr, ok = this.FilterRunners[name]
	return
}

// Starts the provided FilterRunner and adds it to the set of running Filters.
func (this *PipelineConfig) AddFilterRunner(fr FilterRunner) error {
	this.FilterRunners[fr.Name()] = fr
	this.filtersWg.Add(1)
	if err := fr.Start(this, &this.filtersWg); err != nil {
		this.filtersWg.Done()
		return fmt.Errorf("AddFilterRunner '%s' failed to start: %s",
			fRunner.Name(), err)
	} else {
		this.router.AddFilterMatcher() <- fr.MatchRunner()
	}

	return nil
}

// Starts the provided InputRunner and adds it to the set of running Inputs.
func (this *PipelineConfig) AddInputRunner(ir InputRunner, wrapper *PluginWrapper) error {
	this.inputsLock.Lock()
	defer this.inputsLock.Unlock()
	this.inputWrappers[wrapper.name] = wrapper
	this.InputRunners[ir.Name()] = ir
	this.inputsWg.Add(1)
	if err := ir.Start(this, &this.inputsWg); err != nil {
		this.inputsWg.Done()
		return fmt.Errorf("AddInputRunner '%s' failed to start: %s", iRunner.Name(), err)
	}

	return nil
}

func (this *PipelineConfig) ExecuteRuleEngine() {
	var ok bool
	var pluginType string
	for _, w := range ruleEngine.Workers {
		wrapper := new(PluginWrapper)
		wrapper.name = w.Scheme()

		if wrapper.pluginCreator, ok = AvailablePlugins[wrapper.name]; !ok {
			panic(fmt.Sprintf("no plugin[%s] found", wrapper.name))
		}

		plugin := wrapper.pluginCreator()
		wrapper.configCreator = func() interface{} { return w }
		if err := plugin.(Plugin).Init(w); err != nil {
			panic(err)
		}

		// determine plugin type
		pluginCats := PluginTypeRegex.FindStringSubmatch(w.Typ)
		if len(pluginCats) < 2 {
			panic("Type doesn't contain valid plugin name: " + w.Typ)
		}
		pluginCategory := pluginCats[1]
		if pluginCategory == "Decoder" {

		}

		if pluginCategory == "Input" {

		}

		wrapper.Create()
	}
}
