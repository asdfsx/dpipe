package engine

import (
	"encoding/json"
	"fmt"
	conf "github.com/daviddengcn/go-ljson-conf"
	"github.com/funkygao/funpipe/rule"
	"sync"
)

type PipelineConfig struct {
	*conf.Conf

	InputRunners  map[string]InputRunner
	inputWrappers map[string]*PluginWrapper

	FilterRunners  map[string]FilterRunner
	filterWrappers map[string]*PluginWrapper

	OutputRunners  map[string]OutputRunner
	outputWrappers map[string]*PluginWrapper

	router *messageRouter

	inputRecycleChan  chan *PipelinePack
	injectRecycleChan chan *PipelinePack
	reportRecycleChan chan *PipelinePack

	// Stores log messages generated by plugin config errors.
	logMsgs []string

	hostname string
	pid      int32
}

func NewPipelineConfig(globals *GlobalConfigStruct) (this *PipelineConfig) {
	this = new(PipelineConfig)
	if globals == nil {
		globals = DefaultGlobals()
	}

	Globals = func() *GlobalConfigStruct {
		return globals
	}

	this.InputRunners = make(map[string]InputRunner)
	this.inputWrappers = make(map[string]*PluginWrapper)
	this.FilterRunners = make(map[string]FilterRunner)
	this.filterWrappers = make(map[string]*PluginWrapper)
	this.OutputRunners = make(map[string]OutputRunner)
	this.outputWrappers = make(map[string]*PluginWrapper)

	this.router = NewMessageRouter()

	this.inputRecycleChan = make(chan *PipelinePack, 1024)
	this.injectRecycleChan = make(chan *PipelinePack, 1024)
	this.reportRecycleChan = make(chan *PipelinePack, 1)

	this.logMsgs = make([]string, 0, 4)
	this.hostname, _ = os.Hostname()
	this.pid = int32(os.Getpid())

	return config
}

func (this *PipelineConfig) LoadConfigFile(fn string) error {
	cf, err := conf.Load(fn)
	if err != nil {
		return err
	}

	this.Conf = cf

	projects := this.List("projects", nil)
	for i := 0; i < len(projects); i++ {
		keyPrefix := fmt.Sprintf("projects[%d].", i)
		projectName := this.String(keyPrefix+"name", "")
	}

	return nil
}

// Callers should pass in the msgLoopCount value from any relevant Message
// objects they are holding. Returns a PipelinePack for injection into Heka
// pipeline, or nil if the msgLoopCount is above the configured maximum.
func (this *PipelineConfig) PipelinePack(msgLoopCount uint) *PipelinePack {
	if msgLoopCount++; msgLoopCount > Globals().MaxMsgLoops {
		return nil
	}
	pack := <-this.injectRecycleChan
	pack.Message.SetTimestamp(time.Now().UnixNano())
	pack.Message.SetUuid(uuid.NewRandom())
	pack.Message.SetHostname(this.hostname)
	pack.Message.SetPid(this.pid)
	pack.RefCount = 1
	pack.MsgLoopCount = msgLoopCount
	return pack
}

func (this *PipelineConfig) ExecuteRuleEngine() {
	var ok bool
	var pluginType string
	for _, w := range ruleEngine.Workers {
		wrapper := new(PluginWrapper)
		wrapper.name = w.Scheme()

		if wrapper.pluginCreator, ok = AvailablePlugins[wrapper.name]; !ok {
			panic(fmt.Sprintf("no plugin[%s] found", wrapper.name))
		}

		plugin := wrapper.pluginCreator()
		wrapper.configCreator = func() interface{} { return w }
		if err := plugin.(Plugin).Init(w); err != nil {
			panic(err)
		}

		// determine plugin type
		pluginCats := PluginTypeRegex.FindStringSubmatch(w.Typ)
		if len(pluginCats) < 2 {
			panic("Type doesn't contain valid plugin name: " + w.Typ)
		}
		pluginCategory := pluginCats[1]
		if pluginCategory == "Input" {
			this.InputRunners[wrapper.name] = NewInputRunner(wrapper.name, plugin.(Input))
			this.inputWrappers[wrapper.name] = wrapper
		}

		runner := NewFilterOutputRunner(wrapper.name, plugin.(Plugin))
		runner.name = wrapper.name
		runner.matcher = nil

		switch pluginCategory {
		case "Filter":
			this.FilterRunners[runner.name] = runner
		case "Output":
			this.OutputRunners[runner.name] = runner
			this.outputWrappers[runner.name] = wrapper
		}

		wrapper.Create()
	}
}
